# 多线程

多线程（multithreading）是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力
的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。

并发编程：编写多线程代码，解决多线程带来的问题

## 线程和进程

### 概念

- 进程：是指内存中运行的一个应用程序，每个进程都有自己独立的内存空间；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。
- 线程：是进程中的一个执行单元，负责当前进程中任务的执行。一个进程在其执行过程中，会产生很多个线程。

**进程与线程区别**

进程：有独立内存空间，每个进程中的数据空间都是独立的。

线程：多线程之间堆空间与方法区是共享的，但每个线程的栈空间、程序计数器是独立的，线程消
耗的资源比进程小的多。

### 并发与并行

**并发（Concurrent）**：同一时间段，多个任务都在执行 ，单位时间内不⼀定同时执行。

**并行（Parallel）**：单位时间内，多个任务同时执行，单位时间内一定是同时执行。并行上限取决于CPU核数（CPU时间片内50ms）

**※ 并发编程可能导致并行，但是并发编程并不要求是并行的。并发是一种能力，而并行是一种手段。**

### 上下文切换

现在计算机一般都是多核CPU，且OS都能够同时支持远大于CPU内核数的线程运行。那么，OS如何分配CPU资源与调度线程呢？

一个CPU内核，同一时刻只能被一个线程使用。为了提升CPU利用率，CPU采用了时间片算法将CPU时间片轮流分配给多个线程，每个线程分配了一个时间片（几十毫秒/线程），线程在时间片内，使用CPU执行任务。当时间片用完后，线程会被挂起，然后把 CPU 让给其它线程。

- CPU切换前会把当前任务状态保存下来，用于下次切换回任务时再次加载。
- 任务状态的保存及再加载的过程就叫做上下文切换。

**任务状态信息保存**

- 程序计数器：用来存储CPU正在执行的指令的位置，和即将执行的下一条指令的位置。
- 他们都是CPU在运行任何任务前，必须依赖的环境，被叫做CPU上下文。

**上下文切换过程**

1. 挂起当前任务任务，将这个任务在 CPU 中的状态（上下文）存储于内存中的某处。
2. 恢复一个任务，在内存中检索下一个任务的上下文并将在 CPU 的寄存器中恢复。
3. 跳转到程序计数器所指定的位置（即跳转到任务被中断时的代码行）

**线程上下文切换会有什么问题**

过多的线程并行执行会导致CPU资源的争抢，产生频繁的上下文切换，常常表现为高并发执行时，RT延长。因此，合理控制上下文切换次数，可以提高多线程应用的运行效率。（也就是说线程并不是越多越好，要合理的控制线程的数量。）

直接消耗：指的是CPU寄存器需要保存和加载，系统调度器的代码需要执行

间接消耗：指的是多核的cache之间得共享数据，间接消耗对于程序的影响要看线程工作区操作数据的大小

**hw题目 01- 请你说一说什么是线程和进程？**

- 区别

  ```
  进程是资源分配的最小单位，是系统运行程序的基本单位。每个进程都有自己的独立地址内存空间。
  线程是程序执行的最小单位，是cpu调度和分配的基本单位。线程之间的堆空间和方法区共享，栈空间和程序计数器是独立的。
  ```

- 关系

  ```
  一个进程可以包含多个线程，且至少有一个线程，但一个线程只能属于一个进程。
  ```

- 线程的上下文切换是什么？

  ```
  线程的上下文切换指的是在cpu中切换线程执行的过程。
  一个cpu在同一时刻只能被一个线程使用，为了提高效率cpu采用时间片算法将cpu时间片轮流分配给多个线程。
  当一个时间片用完或被阻塞时，cpu会切换线程，把当前线程的执行位置挂起，记录在程序计数器里，用于下次执行时准确查找。然后选择另一个就绪的线程来运行。
  而这个记录与加载的过程，就叫上下文切换。
  ```

- 线程的并发与并行有啥区别？

  ```
  并发是指多个线程在同一时间段内交替执行，但在某一时刻只有一个线程在运行。
  并行是指多个线程在同一时刻同时执行，是真正的多任务处理。并行上限取决于cpu核数。
  ```

### 线程状态：一个线程的一生

Thread源码：Java的线程有六种状态。

```java
public enum State {
	NEW,
	RUNNABLE,
	BLOCKED,
	WAITING,
	TIMED_WAITING,
	TERMINATED;
}
```

NEW(新建) ：线程刚被创建，但是并未启动

RUNNABLE(可运行)：线程可以在Java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器

BLOCKED(锁阻塞)：当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态

WAITING(无限等待)：一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒

TIMED_WAITING(计时等待)：同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait

TERMINATED(被终止)：因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡

![线程状态图](.\note\线程状态图.png)

常用属性：

- 线程名称
- 线程ID：ThreadID = tid
- 线程优先级：Priority

常用方法：

- 线程让步：yield()
- 让线程休眠的方法：sleep()
- 等待线程执行终止的方法： join()
- 线程中断interrupt()
- 等待与通知系列函数wait()、notify()、notifyAll()

wait()与sleep()区别：

- 主要区别：sleep()方法没有释放锁，而wait()方法释放了锁
- 两者都可以暂停线程的执行
- wait()通常用于线程间的交互/通信，sleep()通常用于暂停线程执行
- wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象的notify或notifyAll。
- sleep()方法执行完成后，线程会自动苏醒。或者可以使用wait(long)超时后，线程也会自动苏醒

