# Week 7 Homework

## 题目 01 - 完成 ReadView 案例

解释为什么 RR 和 RC 隔离级别下看到查询结果不一致

要求：

- 完成**案例 01- 读已提交 RC 隔离级别下的可见性分析**
- 完成**案例 02- 可重复读 RR 隔离级别下的可见性分析**
- 用通俗易懂的方式记录整个案例过程，可以画图与截图
- 做完案例给出结论，并对结论进行分析

回答范式：

1. 案例 01- 读已提交 RC 隔离级别下的可见性分析
   - 目标
   
   - 操作步骤
   
   - 实践过程
   
   - 结论
   
     ```
     使用RC隔离级别的事务在每次查询开始时都会生成一个独立的ReadView
     ```
2. 案例 02- 可重复读 RR 隔离级别下的可见性分析
   - 目标
   
   - 操作步骤
   
   - 实践过程
   
   - 结论
   
     ```
     代码与执行流程与RC案例完全相同，唯一不同的是事务隔离级别
     ```
3. 结论分析

## 题目 02 - 什么是索引？

```
数据库索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构。
数据库索引常见的有：主键索引、聚簇索引、覆盖索引、组合索引、前缀索引、唯一索引。
```

**要点：**

1. 优点是什么？

   ```
   可以提高数据检索的效率，降低数据库的IO成本。
   保证数据的唯一性和完整性。
   通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
   ```

2. 缺点是什么？

   ```
   索引会占据磁盘空间，每一个索引都需要占用一定的物理空间，数据量越大占用的空间越大。
   索引虽然会提高查询效率，但每次插入都需查询索引是否冲突，会降低更新表插入操作的效率。
   会增加维护的开销，每次增删改查的时候都需要更新索引，增加系统负担。
   ```

3. 索引分类有哪些？特点是什么？

   ```
   按照索引列的数量有单列索引和组合索引。
   
   单列索引有主键索引、普通索引、唯一索引、全文索引、空间索引和前缀索引。
   主键索引特点是索引列中的值必须是唯一的不允许有空值，保证了索引的唯一性和不为空性。
   普通索引是MySQL中基本索引类型，没有什么限制，特点为允许在定义索引的列中插入重复值和空值。
   唯一索引的特点是索引列中的值必须是唯一的，但是允许为空值。
   全文索引的特点是使用倒排索引的结构，将文本内容分解为若干个词，并建立词和文档之间的映射关系。
   空间索引的特点是使用R-Tree或Quad-Tree等多维数据结构，将空间对象划分为若干个区域，并建立区域和对象之间的映射关系。
   在文本类型如CHAR，VARCHAR，TEXT类列上创建索引时，特点是可以指定索引列的长度，但是数值类型不能指定。
   
   复合索引是在多个列上创建的索引，它可以根据多个条件进行查询。
   复合索引遵循最左前缀原则，即查询条件必须包含复合索引中最左边的列，才能利用该索引。
   ```

4. 索引创建的原则是什么？

   ```
   最左前缀匹配原则
   尽量选择区分度高的列作为索引
   索引列不能参与计算：会导致索引失效，转而使用全表扫描
   范围条件右边的列失效：存储引擎不能使用索引中范围条件右边的列
   尽量使用覆盖索引：只访问索引的查询，索引列和查询列一致，减少使用select *
   索引字段上不要使用不等：不等于【!= 或 <>】，索引会失效
   索引字段上不要判断null：is null，is not null，索引会失效
   索引字段使用like不以通配符开头：like以通配符开头，索引会失效
   索引字段字符串要加单引号：索引会失效
   索引字段不要使用or：索引会失效
   ```

5. 有哪些使用索引的注意事项？

   ```
   需要频繁排序的字段，例如频繁出现在where 条件字段，order排序，group by分组字段，需要索引。
   select 频繁查询的列，考虑是否需要创建联合索引。
   多表join关联查询，on字段两边的字段都要创建索引。
   一个表的索引个数不能过多，每个索引都需要占用磁盘空间，该字段的查询速度会影响整个表的查询速度。太多的索引也会增加优化器的选择时间。
   频繁更新的字段不建议作为索引：频繁更新的字段引发频繁的页分裂和页合并，性能消耗比较高。
   尽量选择分区高的列作为索引。区分度公式是count(distinct col)/count(*)。区分度低的字段使用索引会导致扫描行数过多，再加上回表查询的消耗，性能很差。
   不建议用无序的值作为索引更新数据时会发生频繁的页分裂，页内数据不紧凑，浪费磁盘空间。
   尽量创建组合索引，而不是单列索引。节省空间，可以使用覆盖索引。
   组合索引应该把频繁用到的列、区分度高的值放在前面。频繁使用代表索引的利用率高，区分度高代表筛选粒度大，这样做可最大限度利用索引价值，缩小筛选范围。
   ```

6. 如何知道 SQL 是否用到了索引？

   ```
   使用SHOW INDEX FROM table_name命令
   ```

7. 请你解释一下索引的原理是什么？「重点」

   - 说清楚为什么要用 B+Tree
   
     ```
     没有索引时，数据会进行顺序查找，依次依照数据进行匹配。
     使用某种数据结构的索引可以加快数据的查找。例如使用二叉树，hash表，红黑树，B树，B+树等数据结构。
     Hash table: 
     使用Key Value的形式存储。Key存储索引列，Value记录地址。
     但此数据结构不支持范围快速查找，只能通过扫描全表方式进行索引。
     二叉查找树：
     二叉树最多有两个分支，左子树和右子树数据顺序左小右大。
     时间复杂度和树高相关，因此理想状态下可以达到O(logn)。
     但是极端情况下，二叉查找树会构建成为单向链表 = 查找全表扫描。对磁盘IO将会压力非常大。
     红黑树：
     红黑树是一个近似平衡的二叉树。
     平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。
     在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。
     时间复杂度是 O(log2n)。但时间复杂度同样和书高相关。
     且不支持范围查询快速查找，每次都需要从根节点多次遍历，效率很差。
     B树：
     B树的节点中存储着多个元素，每个节点内有多个分叉。
     节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数据。
     父节点当中的元素不会出现在子节点中，且所有叶子节点都在同一层，叶节点深度相同，之间没有指针链接。
     B树的优点有：
     磁盘IO次数会大大减少。
     比较是在内存中进行的，比较的耗时可以忽略不计。
     B树的高度相比于平衡二叉树会大幅缩小，所以使用B树构建索引可以很好的提升查询的效率。
     但B树同样不支持范围查询的快速查找，每次都需要从根节点重新遍历查找，且空间占用较大，磁盘IO压力大。
     B+树：
     B+树为改进B树，非叶子节点不存储数据的数据结构。
     B+树只有叶子节点才会存储数据，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，非叶子节点只存储Key值。
     这样可以大大加大每个节点存储的key值数量，降低B+树的高度。
     而叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。
     因此在对数据做遍历的时候，只需要对叶子节点进行遍历即可。
     这样B+树既继承了B树的优点，又能保证等值和范围查询的快速查找。
     ```
     
     

## 题目 03 - 什么是 MVCC？

```
MVCC（Multiversion concurrency control）是多版本并发控制。
是RDBMS常用的一种并发控制方法，用来对数据库数据进行并发访问。
它是一种用于解决数据库读写冲突的技术，通过为每个事务提供一个快照视图（ReadView），并根据一定的规则判断数据的可见性，从而实现不同隔离级别下的一致性读取。
核心思想是读不加锁，读写不冲突。
```

**要点：**

1. Redo 日志

   ```
   Redo日志是一种用于记录数据页修改操作的日志文件，它可以保证在事务提交时，把这些修改行为持久化到磁盘中，以防止系统崩溃后数据丢失。Redo日志记录了事务的行为，可以很好地通过其对页进行回滚操作，也就是undo。
   当我们修改一条数据的时候，会把原来的值写到undo log中，当这条更新语句在事务中执行的时候，事务回滚，就可以通过 undo log将数据恢复成原来的值。
   Undo存放在数据库内部的一个特殊段（segment）中，这个段称为Undo段（undo segment）。
   ```

2. ReadView

   ```
   ReadView是张存储事务id的表，主要包含当前系统中有哪些活跃的读写事务。
   开启事务之后，在第一次查询(select)时，生成ReadView。
   
   其中包含了四个重要的属性：m_ids、min_trx_id、max_trx_id 和 。creator_trx_id。
   m_ids：表示在生成ReadView时，当前系统中活跃的读写事务id列表
   m_low_limit_id：事务id下限，表示当前系统中活跃的读写事务中最小的事务id，m_ids事务列表中的最小事务id
   m_up_limit_id：事务id上限，表示生成ReadView时，系统中应该分配给下一个事务的id值
   m_creator_trx_id：表示生成该ReadView的事务的事务id
   ```

3. 如何判断可见性

   ```
   如果 trx_id < min_trx_id，说明该版本在生成 ReadView 之前已经提交，是可见的；
   如果 trx_id >= max_trx_id，说明该版本在生成 ReadView 之后才出现，是不可见的；
   如果 min_trx_id <= trx_id < max_trx_id，说明该版本在生成 ReadView 时是活跃的，需要进一步判断：
   如果 trx_id 在 m_ids 中，说明该版本还未提交，是不可见的；
   如果 trx_id 不在 m_ids 中，说明该版本已经提交，是可见的。
   ```

