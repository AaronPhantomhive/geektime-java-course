# MySQL架构

## 一条Insert语句

```sql
CREATE TABLE `tab_user` (
	`id` int(11) NOT NULL,
	`name` varchar(100) DEFAULT NULL,
	`age` int(11) NOT NULL,
	`address` varchar(255) DEFAULT NULL,
	PRIMARY KEY (`id`)
) ENGINE=InnoDB;
```

然后向这个表里插入一条数据

```sql
Insert into tab_user(id,name,age,address) values (1,'A',18,'xxx');
```

## Insert语句执行流程

![Insert语句执行流程](.\note\Insert语句执行流程.png)

## 事务

**事务指的是逻辑上的一组操作，组成这组操作的各个单元要么全都成功，要么全都失败。**

**事务作用：保证在一个事务中多次SQL操作要么全都成功，要么全都失败。**

MySQL 是一个服务器／客户端架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器连接上之后，就可以称之为一个会话（ Session ）。我们可以同时在不同的会话里输入各种语句，这些语句可以作为事务的一部分进行处理。不同的会话可以同时发送请求，也就是说服务器可能同时在处理多个事务，这样子就会导致不同的事务可能同时访问到相同的记录。

事务的隔离性在理论上是指，在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，所以才会出现各种隔离级别，来最大限度的提升系统并发处理事务的能力，牺牲部分隔离性来提升性能。

### 事务四大特性ACID

数据库事务具有ACID四大特性。ACID是以下4个词的缩写：

- 原子性（Atomicity）： 原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
- 一致性（Consistency）： 事务前后数据的完整性必须保持一致
- 隔离性（Isolation）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干
  扰，多个并发事务之间数据要相互隔离。隔离性由隔离级别保障！
- 持久性（Durability）： 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。

### 事务并发问题

- 脏读：一个事务读到了另一个事务未提交的数据
- 不可重复读：一个事务读到了另一个事务已经提交(update)的数据。引发事务中的多次查询结果不一致
- 虚读 /幻读：一个事务读到了另一个事务已经插入(insert)的数据。导致事务中多次查询的结果不一致

### 隔离级别

- read uncommitted 读未提交【RU】，一个事务读到另一个事务没有提交的数据
  - 存在：3个问题（脏读、不可重复读、幻读）。
- read committed 读已提交【RC】，一个事务读到另一个事务已经提交的数据
  - 存在：2个问题（不可重复读、幻读）。
  - 解决：1个问题（脏读）
- repeatable read:可重复读【RR】，在一个事务中读到的数据始终保持一致，无论另一个事务是否提交
  - 解决：3个问题（脏读、不可重复读、幻读）
- serializable 串行化，同时只能执行一个事务，相当于事务中的单线程
  - 解决：3个问题（脏读、不可重复读、幻读）

#### 安全和性能对比

- 安全性： serializable > repeatable read > read committed > read uncommitted
- 性能 ： serializable < repeatable read < read committed < read uncommitted

#### 常见数据库的默认隔离级别

- MySql： repeatable read
- Oracle： read committed

### 事务底层原理详解

#### 丢失更新问题

两个事务针对同一数据进行修改操作时会丢失更新，这个现象称之为丢失更新问题

#### 解决方案

##### 基于锁并发控制LBCC

使用基于锁的并发控制LBCC（Lock Based Concurrency Control）

##### 基于版本并发控制MVCC

并发控制MVCC（Multi Version Concurrency Control）机制

MVCC使得普通的SELECT请求不加锁，读写不冲突，显著提高了数据库的并发处理能力。MVCC保障了ACID中的隔离性

#### MVCC实现原理【InnoDB】

##### MVCC的定义

> Multiversion concurrency control (MVCC) is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory

MVCC全称叫多版本并发控制，是RDBMS常用的一种并发控制方法，用来对数据库数据进行并发访
问，实现事务。

##### 核心思想

读不加锁，读写不冲突。

##### 实现原理

MVCC 实现原理关键在于数据快照，不同的事务访问不同版本的数据快照，从而实现事务下对数据的隔离级别。

##### 关键要素

MVCC 的实现依赖与Undo日志 与 Read View

**作业题目：什么是 MVCC？**

```
MVCC（Multiversion concurrency control）是多版本并发控制。
是RDBMS常用的一种并发控制方法，用来对数据库数据进行并发访问。
它是一种用于解决数据库读写冲突的技术，通过为每个事务提供一个快照视图（ReadView），并根据一定的规则判断数据的可见性，从而实现不同隔离级别下的一致性读取。
核心思想是读不加锁，读写不冲突。
```

**要点：**

1. Redo 日志

   ```
   Redo日志是一种用于记录数据页修改操作的日志文件，它可以保证在事务提交时，把这些修改行为持久化到磁盘中，以防止系统崩溃后数据丢失。Redo日志记录了事务的行为，可以很好地通过其对页进行回滚操作，也就是undo。
   当我们修改一条数据的时候，会把原来的值写到undo log中，当这条更新语句在事务中执行的时候，事务回滚，就可以通过 undo log将数据恢复成原来的值。
   Undo存放在数据库内部的一个特殊段（segment）中，这个段称为Undo段（undo segment）。
   ```

2. ReadView

   ```
   ReadView是张存储事务id的表，主要包含当前系统中有哪些活跃的读写事务。
   开启事务之后，在第一次查询(select)时，生成ReadView。
   
   其中包含了四个重要的属性：m_ids、min_trx_id、max_trx_id 和 。creator_trx_id。
   m_ids：表示在生成ReadView时，当前系统中活跃的读写事务id列表
   m_low_limit_id：事务id下限，表示当前系统中活跃的读写事务中最小的事务id，m_ids事务列表中的最小事务id
   m_up_limit_id：事务id上限，表示生成ReadView时，系统中应该分配给下一个事务的id值
   m_creator_trx_id：表示生成该ReadView的事务的事务id
   ```

3. 如何判断可见性

   ```
   如果 trx_id < min_trx_id，说明该版本在生成 ReadView 之前已经提交，是可见的；
   如果 trx_id >= max_trx_id，说明该版本在生成 ReadView 之后才出现，是不可见的；
   如果 min_trx_id <= trx_id < max_trx_id，说明该版本在生成 ReadView 时是活跃的，需要进一步判断：
   如果 trx_id 在 m_ids 中，说明该版本还未提交，是不可见的；
   如果 trx_id 不在 m_ids 中，说明该版本已经提交，是可见的。
   ```

# MySQL索引篇

## 一条Select语句

```mysql
select * from tab_user WHERE id=1
```

索引往往是存储在磁盘上的文件中的

我们通常所说的索引，包括聚簇索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织的索引

## 优势和劣势

优势：

- 可以提高数据检索的效率，降低数据库的IO成本，类似于书的目录。
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
  - 被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。
  - 如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。

劣势：

- 索引会占据磁盘空间
- 索引虽然会提高查询效率，但是会降低更新表的效率。比如每次对表进行增删改操作，MySQL不仅要保存数据，还要维护索引文件。

## 索引的使用

按照索引列的数量分类：

- 单列索引：索引中只有一个列。
- 组合索引：使用2个以上的字段创建的索引

### 单列索引

- 主键索引：索引列中的值必须是唯一的不允许有空值。

```mysql
ALTER TABLE table_name ADD PRIMARY KEY (column_name);
```

- 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。

```mysql
ALTER TABLE table_name ADD INDEX index_name (column_name);
```

- 唯一索引：索引列中的值必须是唯一的，但是允许为空值。

```mysql
CREATE UNIQUE INDEX index_name ON table(column_name);
```

- 全文索引：只能在文本类型CHAR，VARCHAR，TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以使用全文索引。
- 空间索引：MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。
- 前缀索引：在文本类型如CHAR，VARCHAR，TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。

### 组合索引

- 组合索引的使用，需要遵循最左前缀原则
- 一般情况下，建议使用组合索引代替单列索引

```mysql
ALTER TABLE table_name ADD INDEX index_name (column1,column2);
```

### 删除索引

```mysql
DROP INDEX index_name ON table
```

### 查看索引

```mysql
SHOW INDEX FROM table_name
```

## 索引的数据结构

Hash表，二叉树，平衡二叉查找树（红黑树是一个近似平衡二叉树），B树，B+树。

### Hash表

Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；

- 但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。
- 数据结构比较稀疏，不适合做聚合，不适合做范围等查找。

使用场景：

- 对查询并发要求很高，K/V内存数据库，缓存

### 二叉查找树

二叉树特点：每个节点最多有2个分叉，左子树和右子树数据顺序左小右大。

二叉树的检索复杂度和树高相关：理想状态下效率可以达到O(logn)

### 红黑树

红黑树是一个近似平衡的二叉树

平衡二叉树是采用二分法思维，平衡二叉查找树除了具备二叉树的特点，最主要的特征是树的左右两个子树的层级最多相差1。在插入删除数据时通过左旋/右旋操作保持二叉树的平衡，不会出现左子树很高、右子树很矮的情况。

使用平衡二叉查找树查询的性能接近于二分查找法，时间复杂度是 O(log2n)。

平衡二叉树存在的问题
1. 时间复杂度和树高相关：树有多高就需要检索多少次，每个节点的读取，都对应一次磁盘 IO 操作【瓶颈】。
  - 磁盘每次寻道时间为10ms，在表数据量大时，对响应时间要求高的场景下，查询性能就会出
    现瓶颈。
  - 举例：1百万的数据量，log2n约等于20次磁盘IO，时间20*10=0.2s
2. 平衡二叉树不支持范围查询快速查找，范围查询时需要从根节点多次遍历，查询效率极差。
3. 数据量大的情况下，索引存储空间占用巨大

### B树：改进二叉树，为多叉树

想要减少耗时的IO操作，就要尽量降低树的高度。每个节点存储多个元素，在每个节点尽可能多的存储数据。每个节点可以存储1000个索引（16k/16=1000），这样就将二叉树改造成了多叉树，通过增加树的叉树，将树从高瘦变为矮胖

主要特点：
1. B树的节点中存储着多个元素，每个节点内有多个分叉。
2. 节点中的元素包含键值和数据，节点中的键值从大到小排列。也就是说，在所有的节点都储存数
据。
3. 父节点当中的元素不会出现在子节点中。
4. 所有的叶子结点都位于同一层，叶节点具有相同的深度，叶节点之间没有指针连接。

以下面的B树为例，我们的键值为表主键，具备唯一性。

![B树](.\note\B树.png)

B树如何查询数据？：假如我们查询值等于15的数据。查询路径磁盘块1->磁盘块2->磁盘块7。

优点：

- 磁盘IO次数会大大减少。
- 比较是在内存中进行的，比较的耗时可以忽略不计。
- B树的高度相比于平衡二叉树会大幅缩小，所以使用B树构建索引可以很好的提升查询的效率

缺点：

- B树不支持范围查询的快速查找：如果我们想要查找15和26之间的数据，查找到15之后，需要回到根节点重新遍历查找，需要从根节点进行多次遍历，查询效率有待提高。
- 空间占用较大：如果data存储的是行记录，行的大小随着列数的增多，所占空间会变大。一个页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大

### B+树：改进B树，非叶子节点不存储数据

在B树基础上，MySQL在B树的基础上继续改造，使用B+树构建索引。B+树和B树最主要的区别在于非叶子节点是否存储数据的问题

- B树：非叶子节点和叶子节点都会存储数据。
- B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。

B+树的最底层叶子节点包含所有索引项。具备中路返回特性

![B+树](.\note\B+树.png)

等值查询：假如我们查询值等于15的数据。查询路径磁盘块1->磁盘块2->磁盘块5。

范围查询：假如我们想要查找15和26之间的数据。

- 查找路径是磁盘块1->磁盘块2->磁盘块5。
- 首先查找值等于15的数据，将值等于15的数据缓存到结果集【三次磁盘IO】。
- 查找到15之后，底层的叶子节点是一个有序列表，我们从磁盘块5，键值15开始向后遍历筛选所有符合筛选条件的数据。
- 第四次磁盘IO：根据磁盘5后继指针到磁盘中寻址定位到磁盘块6，将磁盘6加载到内存中，在内存中从头遍历比较，15<17<26，15<26<=26，将data缓存到结果集。

优点：

- 继承了B树的优点【多叉树的优点】
- 保证等值和范围查询的快速查找
- MySQL的索引就采用了B+树的数据结构。

## 索引创建原则

### 需要创建索引的情况

- 频繁出现在where 条件字段，order排序，group by分组字段
- select 频繁查询的列，考虑是否需要创建联合索引（覆盖索引，不回表）
- 多表join关联查询，on字段两边的字段都要创建索引

